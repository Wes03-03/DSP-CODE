/*******************************************************************
Analog Devices, Inc. All Rights Reserved.

This software is proprietary and confidential.  By using this software
you agree to the terms of the associated Analog Devices License Agreement.

Project Name:  	Power_On_Self_Test

Hardware:		ADSP-21479/21489 EZ-Board

Description:	This file tests the analog audio interface on the EZ-Board.
*******************************************************************/

/*******************************************************************
*  include files
*******************************************************************/
#ifdef __ADSP21489__
#include <cdef21489.h>
#include <def21489.h>
#elif __ADSP21479__
#include <cdef21479.h>
#include <def21479.h>
#endif
#include <sru.h>
#include <signal.h>
#include <sysreg.h>
#include <filter.h>
#include <complex.h>
#include <stdlib.h>
#include "ad1939.h"
#include "analog_audio_test.h"
#include "post_debug.h"
#include <services\int\adi_int.h>


/*******************************************************************
*  function prototypes
*******************************************************************/

void Init_DAI_I2S(void);
void Init_TDM_DAI(MODE_SAMPLE_RATE sampe_rate);

void  process_AD1939_samples_ISR( int, void *);
#if 0 //(BDR)
int Audio_Test_Channel(float* pfRealIn, const int iMaxSamples, const int iSampleRate,
const float fExpFreq, const float fFreqTol, const float fExpAmp, const float fAmpTol);
#endif


void 	enable_SPORT012_I2S_mode(void);
void 	enable_SPORT01_MCM_mode(MODE_SAMPLE_RATE);
void 	enable_SPORT01_DMA_channels(MODE_SAMPLE_RATE);
void Init1939viaSPI(MODE_SAMPLE_RATE mode_sampe_rate);
void SetupSPI1939(unsigned int SPI_Flag);
void DisableSPI1939(void);
void Configure1939Register (unsigned char rwaddr,unsigned char regaddr,
						unsigned char regdata, unsigned int spiselect);
int 	Test_Audio(MODE_SAMPLE_RATE sampe_rate);

int 	Test_Codec_TDM_I2S(bool);

/*******************************************************************
*  global variables and defines
*******************************************************************/

/* Setup the SPI parameters here in a buffer first */
unsigned char ConfigParam1939_48KHZ_I2S [] = {
            (AD1939_ADDR), DACMUTE, 0x00,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_I2S | DAC_BCLK_DLY_1 | DAC_SR_48K,
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_48K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_I2S | ADC_BCLK_DLY_1 | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0x00,
            } ;

unsigned char ConfigParam1939_48KHZ_I2S_OUT12 [] = {
            (AD1939_ADDR), DACMUTE, 0xF0,		// mute DAC 3,4 right and left
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_I2S | DAC_BCLK_DLY_1 | DAC_SR_48K,
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_48K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_I2S | ADC_BCLK_DLY_1 | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0xF0,		// mute DAC 3,4 right and left
            } ;

unsigned char ConfigParam1939_48KHZ_I2S_OUT34 [] = {
            (AD1939_ADDR), DACMUTE, 0x0F, 		// mute DAC 1&2 right and left
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_I2S | DAC_BCLK_DLY_1 | DAC_SR_48K,
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_48K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_I2S | ADC_BCLK_DLY_1 | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0x0F,		// mute DAC 1&2 right and left
            } ;

unsigned char ConfigParam1939_96KHZ_I2S [] = {
            (AD1939_ADDR), DACMUTE, 0x00,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_I2S | DAC_BCLK_DLY_1 | DAC_SR_96K,
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_96K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_I2S | ADC_BCLK_DLY_1 | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0x00,
            } ;

unsigned char ConfigParam1939_96KHZ_I2S_OUT12 [] = {
            (AD1939_ADDR), DACMUTE, 0xF0,		// mute DAC 3,4 right and left
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_I2S | DAC_BCLK_DLY_1 | DAC_SR_96K,
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_96K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_I2S | ADC_BCLK_DLY_1 | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0xF0,		// mute DAC 3,4 right and left
            } ;

unsigned char ConfigParam1939_96KHZ_I2S_OUT34 [] = {
            (AD1939_ADDR), DACMUTE, 0x0F,		// mute DAC 1&2 right and left
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_I2S | DAC_BCLK_DLY_1 | DAC_SR_96K,
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_96K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_I2S | ADC_BCLK_DLY_1 | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0x0F,		// mute DAC 1&2 right and left
            } ;

unsigned char ConfigParam1939_192KHZ_I2S [] = {
            (AD1939_ADDR), DACMUTE, 0x00,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_I2S | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_192K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_I2S | ADC_BCLK_DLY_1 | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0x00,
            } ;

unsigned char ConfigParam1939_192KHZ_I2S_OUT12 [] = {
            (AD1939_ADDR), DACMUTE, 0xF0,		// mute DAC 3,4 right and left
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_I2S | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_192K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_I2S | ADC_BCLK_DLY_1 | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0xF0,		// mute DAC 3,4 right and left
            } ;

unsigned char ConfigParam1939_192KHZ_I2S_OUT34 [] = {
            (AD1939_ADDR), DACMUTE, 0x0F,		// mute DAC 1&2 right and left
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_I2S | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL1,  DAC_BCLK_SLAVE| DAC_LRCLK_SLAVE  | DAC_CHANNELS_2 | DAC_LATCH_MID, //Ddebug
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_192K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_I2S | ADC_BCLK_DLY_1 | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_2 | ADC_LRCLK_MASTER  | ADC_LRCLK_FMT_50_50|ADC_LRCLK_POL_NORM|ADC_BCLK_POL_NORM, // NDdebug
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0x0F,		// mute DAC 1&2 right and left
            } ;
/* Setup the SPI parameters here in a buffer first */
/* NOTE:  AD1939_ADDR:DACMUTE register mutes DAC2 and DAC3 due to duplication side effect
          of DAC1 and DAC2 out of DAC3 and DAC4 in 192 kHz dual-line TDM mode */
/* Setup the SPI parameters here in a buffer first */
unsigned char ConfigParam1939_48KHZ_TDM [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_TDM | DAC_BCLK_DLY_1 | DAC_SR_48K,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_8 | DAC_LATCH_MID,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_48K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_AUX | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_LRCLK_FMT_PULSE | ADC_BCLK_MASTER | ADC_LRCLK_MASTER | ADC_BCLK_SRC_PIN | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_CHANNELS_8,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            } ;

unsigned char ConfigParam1939_48KHZ_TDM_OUT12 [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_TDM | DAC_BCLK_DLY_1 | DAC_SR_48K,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_8 | DAC_LATCH_MID,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_48K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_AUX | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_LRCLK_FMT_PULSE | ADC_BCLK_MASTER | ADC_LRCLK_MASTER | ADC_BCLK_SRC_PIN | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_CHANNELS_8,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0xF0,		// mute DAC 3,4 right and left
            } ;
unsigned char ConfigParam1939_48KHZ_TDM_OUT34 [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_TDM | DAC_BCLK_DLY_1 | DAC_SR_48K,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_8 | DAC_LATCH_MID,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_48K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_AUX | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_LRCLK_FMT_PULSE | ADC_BCLK_MASTER | ADC_LRCLK_MASTER | ADC_BCLK_SRC_PIN | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_CHANNELS_8,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0x0F,		// mute DAC 1,2 right and left
            } ;

unsigned char ConfigParam1939_96KHZ_TDM [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_TDM | DAC_BCLK_DLY_1 | DAC_SR_96K,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_8 | DAC_LATCH_MID,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_96K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_AUX | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_LRCLK_FMT_PULSE | ADC_BCLK_MASTER | ADC_LRCLK_MASTER | ADC_BCLK_SRC_PIN | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_CHANNELS_8,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            } ;

unsigned char ConfigParam1939_96KHZ_TDM_OUT12 [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_TDM | DAC_BCLK_DLY_1 | DAC_SR_96K,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_8 | DAC_LATCH_MID,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_96K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_AUX | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_LRCLK_FMT_PULSE | ADC_BCLK_MASTER | ADC_LRCLK_MASTER | ADC_BCLK_SRC_PIN | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_CHANNELS_8,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0xF0,		// mute DAC 3,4 right and left
            } ;

unsigned char ConfigParam1939_96KHZ_TDM_OUT34 [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_TDM | DAC_BCLK_DLY_1 | DAC_SR_96K,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_8 | DAC_LATCH_MID,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_96K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_AUX | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_LRCLK_FMT_PULSE | ADC_BCLK_MASTER | ADC_LRCLK_MASTER | ADC_BCLK_SRC_PIN | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_CHANNELS_8,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0x0F,		// mute DAC 1,2 right and left
            } ;

unsigned char ConfigParam1939_192KHZ_TDM [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_4 | DAC_LATCH_MID | DAC_BCLK_SLAVE | DAC_LRCLK_SLAVE,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_4 | DAC_LATCH_MID | DAC_BCLK_SLAVE | DAC_LRCLK_SLAVE,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
	        (AD1939_ADDR), DACCTRL0, DAC_FMT_DUALTDM | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_DUALTDM | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_192K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_TDM | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_4 | ADC_LRCLK_MASTER | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_LRCLK_FMT_PULSE,
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0x00,
            };

unsigned char ConfigParam1939_192KHZ_TDM_OUT12 [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_4 | DAC_LATCH_MID | DAC_BCLK_SLAVE | DAC_LRCLK_SLAVE,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_4 | DAC_LATCH_MID | DAC_BCLK_SLAVE | DAC_LRCLK_SLAVE,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
	        (AD1939_ADDR), DACCTRL0, DAC_FMT_DUALTDM | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_DUALTDM | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_192K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_TDM | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_4 | ADC_LRCLK_MASTER | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_LRCLK_FMT_PULSE,
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0xF0,		// mute DAC 3,4 right and left
            };

unsigned char ConfigParam1939_192KHZ_TDM_OUT34 [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_4 | DAC_LATCH_MID | DAC_BCLK_SLAVE | DAC_LRCLK_SLAVE,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_4 | DAC_LATCH_MID | DAC_BCLK_SLAVE | DAC_LRCLK_SLAVE,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
	        (AD1939_ADDR), DACCTRL0, DAC_FMT_DUALTDM | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_DUALTDM | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_192K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_TDM | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_4 | ADC_LRCLK_MASTER | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_LRCLK_FMT_PULSE,
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0x0F,		// mute DAC 1,2 right and left
            };
unsigned char ConfigParam1939ExtA_192_TDM_OUT [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACMUTE, 0xFF,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_4 | DAC_LATCH_MID | DAC_BCLK_SLAVE | DAC_LRCLK_SLAVE,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
	        (AD1939_ADDR), DACCTRL0, DAC_FMT_DUALTDM | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_192K,
        	(AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_TDM | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_4 | ADC_LRCLK_MASTER | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_LRCLK_FMT_PULSE,
            (AD1939_ADDR), DACVOL_L1, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R1, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_L2, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R2, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_L3, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R3, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_L4, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R4, DACVOL_MAX,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0x00
            };

unsigned char ConfigParam1939ExtA_192_TDM_OUT12 [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACMUTE, 0xFF,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_4 | DAC_LATCH_MID | DAC_BCLK_SLAVE | DAC_LRCLK_SLAVE,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
	        (AD1939_ADDR), DACCTRL0, DAC_FMT_DUALTDM | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_192K,
        	(AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_TDM | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_4 | ADC_LRCLK_MASTER | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_LRCLK_FMT_PULSE,
            (AD1939_ADDR), DACVOL_L1, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R1, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_L2, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R2, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_L3, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R3, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_L4, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R4, DACVOL_MAX,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0xF0	// mute DAC 3,4 right and left
            };

unsigned char ConfigParam1939ExtA_192_TDM_OUT34 [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACMUTE, 0xFF,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_4 | DAC_LATCH_MID | DAC_BCLK_SLAVE | DAC_LRCLK_SLAVE,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
	        (AD1939_ADDR), DACCTRL0, DAC_FMT_DUALTDM | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_192K,
        	(AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_TDM | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_INTERNAL | ADC_BCLK_MASTER | ADC_CHANNELS_4 | ADC_LRCLK_MASTER | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_LRCLK_FMT_PULSE,
            (AD1939_ADDR), DACVOL_L1, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R1, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_L2, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R2, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_L3, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R3, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_L4, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R4, DACVOL_MAX,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0x0F	// mute DAC 1, 2 right and left
            };


unsigned char ConfigParam1939ExtB_192_TDM_OUT12 [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACMUTE, 0xFF,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_4 | DAC_LATCH_MID | DAC_BCLK_SLAVE | DAC_LRCLK_SLAVE,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
	        (AD1939_ADDR), DACCTRL0, DAC_FMT_DUALTDM | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_192K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_TDM | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_PIN | ADC_BCLK_SLAVE | ADC_CHANNELS_4 | ADC_LRCLK_SLAVE | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_LRCLK_FMT_PULSE,
            (AD1939_ADDR), DACVOL_L1, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R1, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_L2, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R2, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_L3, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R3, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_L4, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R4, DACVOL_MAX,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
	       	(AD1939_ADDR), DACMUTE, 0xF0		// mute DAC 3,4 right and left
            };

unsigned char ConfigParam1939ExtB_192_TDM_OUT34 [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACMUTE, 0xFF,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_4 | DAC_LATCH_MID | DAC_BCLK_SLAVE | DAC_LRCLK_SLAVE,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
	        (AD1939_ADDR), DACCTRL0, DAC_FMT_DUALTDM | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_192K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_TDM | ADC_WIDTH_24,
            (AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_PIN | ADC_BCLK_SLAVE | ADC_CHANNELS_4 | ADC_LRCLK_SLAVE | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_LRCLK_FMT_PULSE,
            (AD1939_ADDR), DACVOL_L1, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R1, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_L2, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R2, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_L3, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R3, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_L4, DACVOL_MAX,
            (AD1939_ADDR), DACVOL_R4, DACVOL_MAX,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
	       	(AD1939_ADDR), DACMUTE, 0x0F		// mute DAC 1,2 right and left
            };


unsigned char ConfigParam1939ExtC_192_TDM_OUT12 [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACMUTE, 0xFF,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_4 | DAC_LATCH_MID | DAC_BCLK_SLAVE | DAC_LRCLK_SLAVE,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_DUALTDM | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_192K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_TDM | ADC_WIDTH_24,
 			(AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_PIN | ADC_BCLK_SLAVE | ADC_CHANNELS_4 | ADC_LRCLK_SLAVE | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_LRCLK_FMT_PULSE,
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0xF0		// mute DAC 3,4 right and left
            };

unsigned char ConfigParam1939ExtC_192_TDM_OUT34 [] = {
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN,
            (AD1939_ADDR), CLKCTRL1, DAC_CLK_PLL | ADC_CLK_PLL | DIS_VREF,
            (AD1939_ADDR), DACMUTE, 0xFF,
            (AD1939_ADDR), DACCTRL1, DAC_LRCLK_POL_INV | DAC_BCLK_POL_INV | DAC_CHANNELS_4 | DAC_LATCH_MID | DAC_BCLK_SLAVE | DAC_LRCLK_SLAVE,
            (AD1939_ADDR), DACCTRL2, DAC_WIDTH_24,
            (AD1939_ADDR), DACCTRL0, DAC_FMT_DUALTDM | DAC_BCLK_DLY_1 | DAC_SR_192K,
            (AD1939_ADDR), ADCCTRL0, ADC_SR_192K,
            (AD1939_ADDR), ADCCTRL1, ADC_LATCH_MID | ADC_FMT_TDM | ADC_WIDTH_24,
 			(AD1939_ADDR), ADCCTRL2, ADC_BCLK_SRC_PIN | ADC_BCLK_SLAVE | ADC_CHANNELS_4 | ADC_LRCLK_SLAVE | ADC_LRCLK_POL_INV | ADC_BCLK_POL_INV | ADC_LRCLK_FMT_PULSE,
            (AD1939_ADDR), DACVOL_L1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R1, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R2, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R3, DACVOL_HI,
            (AD1939_ADDR), DACVOL_L4, DACVOL_HI,
            (AD1939_ADDR), DACVOL_R4, DACVOL_HI,
            (AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), CLKCTRL0, ENA_ADC_DAC | PLL_IN_MCLK | MCLK_OUT_OFF | INPUT256 | PLL_PWR_UP,
            (AD1939_ADDR), DACMUTE, 0x0F		// mute DAC 1,2 right and left
            };

unsigned char ConfigParam1939Ext_Codec_OFF[]= {
	(AD1939_ADDR), CLKCTRL0, DIS_ADC_DAC | INPUT256 | PLL_IN_MCLK | MCLK_OUT_OFF | PLL_PWR_DWN
};


int	 	I2S_rx1a_buf[2];   /* SPORT1 receive buffer A (DMA) */
int	 	I2S_rx1b_buf[2];   /* SPORT1 receive buffer B (DMA) */
int 	I2S_tx0a_buf[2];   /* SPORT0 transmit buffer A (DMA) */
int 	I2S_tx0b_buf[2];   /* SPORT0 transmit buffer B (DMA) */
int 	I2S_tx2a_buf[2];   /* SPORT2 transmit buffer A (DMA) */
int 	I2S_tx2b_buf[2];   /* SPORT2 transmit buffer B (DMA) */


/* TCB = "Transfer Control Block" */
/* TCB format:    ECx (length of destination buffer),
				  EMx (destination buffer step size),
				  EIx (destination buffer index (initialized to start address)),
				  GPx ("general purpose"),
				  CPx ("Chain Point register"; points to last address (IIx) of
			   								   next TCB to jump to
				                               upon completion of this TCB.),
				  Cx  (length of source buffer),
				  IMx (source buffer step size),
				  IIx (source buffer index (initialized to start address))       */

int 	I2S_rcv1a_tcb[8]  = {0, 0, 0, 0, 0, 2, 1, (int) I2S_rx1a_buf};	/* SPORT1 receive a tcb */
int 	I2S_rcv1b_tcb[8]  = {0, 0, 0, 0, 0, 2, 1, (int) I2S_rx1b_buf};	/* SPORT1 receive b tcb */
int 	I2S_xmit0a_tcb[8] = {0, 0, 0, 0, 0, 2, 1, (int) I2S_tx0a_buf};  /* SPORT0 transmit a tcb */
int 	I2S_xmit0b_tcb[8] = {0, 0, 0, 0, 0, 2, 1, (int) I2S_tx0b_buf};  /* SPORT0 transmit a tcb */
int 	I2S_xmit2a_tcb[8] = {0, 0, 0, 0, 0, 2, 1, (int) I2S_tx2a_buf};  /* SPORT2 transmit a tcb */
int 	I2S_xmit2b_tcb[8] = {0, 0, 0, 0, 0, 2, 1, (int) I2S_tx2b_buf};  /* SPORT2 transmit a tcb */


//////////////////////////////////////////////////////
// TDM definitions for 48 or 96 kHz sample rate
//
//////////////////////////////////////////////////////

int	 	TDM_4896_rx1a_buf[8];   /* receive buffer A (DMA)*/
int 	TDM_4896_tx0a_buf[8];   /* transmit buffer A (DMA)*/

int 	TDM_4896_rcv1a_tcb[8]  = {0, 0, 0, 0, 0, 8, 1, (int) TDM_4896_rx1a_buf};	/* SPORT1 receive tcb */
int 	TDM_4896_xmit0a_tcb[8] = {0, 0, 0, 0, 0, 8, 1, (int) TDM_4896_tx0a_buf};  /* SPORT0 transmit tcb */

//////////////////////////////////////////////////////
// TDM definitions for 192 kHz sample rate
//
//////////////////////////////////////////////////////
int TDM_rx1a_buf[4];
int TDM_tx0a_buf[4];
int TDM_tx0b_buf[4];


//TDM
int 	TDM_rcv1a_tcb[8]  = {0, 0, 0, 0, 0, 4, 1, (int) TDM_rx1a_buf};	/* SPORT1 receive tcb */
int 	TDM_xmit0a_tcb[8] = {0, 0, 0, 0, 0, 4, 1, (int) TDM_tx0a_buf};  /* SPORT0 transmit A tcb */
int 	TDM_xmit0b_tcb[8] = {0, 0, 0, 0, 0, 4, 1, (int) TDM_tx0b_buf};  /* SPORT0 transmit B tcb */

MODE_SAMPLE_RATE g_mode_sample_rate;

volatile int spiFlag ;

int ext_rx1a_buf[4];
int ext_tx0a_buf[4];
int ext_tx0b_buf[4];

int ext_rx3a_buf[4];
int ext_tx2a_buf[4];
int ext_tx2b_buf[4];

int ext_rx5a_buf[4];
int ext_tx4a_buf[4];
int ext_tx4b_buf[4];

section("seg_sdram") volatile float g_fSineWaveIn1_Left[AUDIO_MAX_SAMPLES];
section("seg_sdram") volatile float g_fSineWaveIn1_Right[AUDIO_MAX_SAMPLES];
section("seg_sdram") volatile float g_fSineWaveIn2_Left[AUDIO_MAX_SAMPLES];
section("seg_sdram") volatile float g_fSineWaveIn2_Right[AUDIO_MAX_SAMPLES];
section("seg_sdram") volatile float g_fSineWaveInB1_Left[AUDIO_MAX_SAMPLES];
section("seg_sdram") volatile float g_fSineWaveInB1_Right[AUDIO_MAX_SAMPLES];
section("seg_sdram") volatile float g_fSineWaveInB2_Left[AUDIO_MAX_SAMPLES];
section("seg_sdram") volatile float g_fSineWaveInB2_Right[AUDIO_MAX_SAMPLES];
section("seg_sdram") volatile float g_fSineWaveInC1_Left[AUDIO_MAX_SAMPLES];
section("seg_sdram") volatile float g_fSineWaveInC1_Right[AUDIO_MAX_SAMPLES];
section("seg_sdram") volatile float g_fSineWaveInC2_Left[AUDIO_MAX_SAMPLES];
section("seg_sdram") volatile float g_fSineWaveInC2_Right[AUDIO_MAX_SAMPLES];


/*******************************************************************
*   Function:    Test_Analog_Audio_RCA
*   Description: Tests the analog audio. This test is used for
*                RCA and headphone test. It is one time test
*******************************************************************/

int Test_Analog_Audio_RCA(void)
{
	bool bFlag=false;
	DEBUG_HEADER( "Analog Audio RCA Test" );

	return Test_Codec_TDM_I2S(bFlag); //on board codec test

}

/*******************************************************************
*   Function:    Test_Analog_Audio_Diff
*   Description: Tests the analog audio. This test is used for
*                differential test. It is one time test
*******************************************************************/

int Test_Analog_Audio_Diff(void)
{
	int iRet;
	DEBUG_HEADER( "Analog Audio Differential Test" );

    SinTableInit();

   	DEBUG_STATEMENT("\nTesting audio TDM 48 KHZ sample rate port 12......");
    iRet = Test_Audio(TDM_48_KHZ_SAMPLE_RATE_OUT12);
    if(iRet==0)
    {
    	DEBUG_STATEMENT("failed.");
    	return iRet;

    }
    DEBUG_STATEMENT("passed.");
    DEBUG_STATEMENT("\nTesting audio TDM 192 KHZ sample rate port 12......");
    iRet = Test_Audio(TDM_192_KHZ_SAMPLE_RATE_OUT12);
    if(iRet==0)
    {
    	DEBUG_STATEMENT("failed.\n");
    	return iRet;

    }
    DEBUG_STATEMENT("passed.");
    DEBUG_STATEMENT("\nTesting audio I2S 48 KHZ sample rate port 12......");
    iRet = Test_Audio(I2S_48_KHZ_SAMPLE_RATE_OUT12);
    if(iRet==0)
    {
    	DEBUG_STATEMENT("failed.\n");
    	return iRet;

    }
    DEBUG_STATEMENT("passed.");
    DEBUG_STATEMENT("\nTesting audio I2S 192 KHZ sample rate port 12......");
    iRet = Test_Audio(I2S_192_KHZ_SAMPLE_RATE_OUT12);
    if(iRet==0)
    {
    	DEBUG_STATEMENT("failed.\n");
    	return iRet;

    }
    DEBUG_STATEMENT("passed.");
    
    	
	DEBUG_STATEMENT("\n\nTest passed");
	return 1;
}

int Test_Codec_TDM_I2S(bool bExtendBoard)
{
	int iRet;

    SinTableInit();
    if(bExtendBoard)
    {
    	// turn off code B and C on extender board
    	Init1939viaSPI(EXTB_CODEC_OFF);
    	Init1939viaSPI(EXTC_CODEC_OFF);

    }

   	DEBUG_STATEMENT("\nTesting audio TDM 48 KHZ sample rate port 12......");
    iRet = Test_Audio(TDM_48_KHZ_SAMPLE_RATE_OUT12);
    if(iRet==0)
    {
    	DEBUG_STATEMENT("failed.");
    	return iRet;

    }
    DEBUG_STATEMENT("passed.");
    DEBUG_STATEMENT("\nTesting audio TDM 48 KHZ sample rate port 34......");
    iRet = Test_Audio(TDM_48_KHZ_SAMPLE_RATE_OUT34);
    if(iRet==0)
    {
    	DEBUG_STATEMENT("failed.\n");
    	return iRet;

    }
    DEBUG_STATEMENT("passed.");
    DEBUG_STATEMENT("\nTesting audio TDM 192 KHZ sample rate port 12......");
    iRet = Test_Audio(TDM_192_KHZ_SAMPLE_RATE_OUT12);
    if(iRet==0)
    {
    	DEBUG_STATEMENT("failed.\n");
    	return iRet;

    }
    DEBUG_STATEMENT("passed.");
    DEBUG_STATEMENT("\nTesting audio TDM 192 KHZ sample rate port 34......");
    iRet = Test_Audio(TDM_192_KHZ_SAMPLE_RATE_OUT34);
    if(iRet==0)
    {
    	DEBUG_STATEMENT("failed.\n");
    	return iRet;

    }
    DEBUG_STATEMENT("passed.");
    DEBUG_STATEMENT("\nTesting audio I2S 48 KHZ sample rate port 12......");
    iRet = Test_Audio(I2S_48_KHZ_SAMPLE_RATE_OUT12);
    if(iRet==0)
    {
    	DEBUG_STATEMENT("failed.\n");
    	return iRet;

    }
    DEBUG_STATEMENT("passed.");
    DEBUG_STATEMENT("\nTesting audio I2S 48 KHZ sample rate port 34......");
    iRet = Test_Audio(I2S_48_KHZ_SAMPLE_RATE_OUT34);
    if(iRet==0)
    {
    	DEBUG_STATEMENT("failed.\n");
    	return iRet;

    }
    DEBUG_STATEMENT("passed.");
    DEBUG_STATEMENT("\nTesting audio I2S 192 KHZ sample rate port 12......");
    iRet = Test_Audio(I2S_192_KHZ_SAMPLE_RATE_OUT12);
    if(iRet==0)
    {
    	DEBUG_STATEMENT("failed.\n");
    	return iRet;

    }
    DEBUG_STATEMENT("passed.");
    DEBUG_STATEMENT("\nTesting audio I2S 192 KHZ sample rate port 34......");
    iRet = Test_Audio(I2S_192_KHZ_SAMPLE_RATE_OUT34);
    if(iRet==0)
    {
    	DEBUG_STATEMENT("failed.\n");
    	return iRet;

    }
    DEBUG_STATEMENT("passed.");


	DEBUG_STATEMENT("\n\nTest passed");
	return 1;

}




/*******************************************************************
*   Function:    Clear_DAI_Pins
*   Description: Set DAI pins to known startup state.
*******************************************************************/

void Clear_DAI_Pins(void)
{
	/****************************************************
	Tie the pin buffer inputs LOW for all DAI pins.  Even though
	these pins are inputs to the SHARC, tying unused pin buffer inputs
	LOW is "good coding style" to eliminate the possibility of
	termination artifacts internal to the IC.  Note that signal
	integrity is degraded only with a few specific SRU combinations.
	In practice, this occurs VERY rarely, and these connections are
	typically unnecessary.  This is GROUP D.
	****************************************************/

    SRU(LOW, DAI_PB01_I);
    SRU(LOW, DAI_PB02_I);
    SRU(LOW, DAI_PB03_I);
    SRU(LOW, DAI_PB04_I);
    SRU(LOW, DAI_PB05_I);
    SRU(LOW, DAI_PB06_I);
    SRU(LOW, DAI_PB07_I);
    SRU(LOW, DAI_PB08_I);
    SRU(LOW, DAI_PB09_I);
    SRU(LOW, DAI_PB10_I);
    SRU(LOW, DAI_PB11_I);
    SRU(LOW, DAI_PB12_I);
    SRU(LOW, DAI_PB13_I);
    SRU(LOW, DAI_PB14_I);
    SRU(LOW, DAI_PB15_I);
    SRU(LOW, DAI_PB16_I);
    SRU(LOW, DAI_PB17_I);
    SRU(LOW, DAI_PB18_I);
    SRU(LOW, DAI_PB19_I);
    SRU(LOW, DAI_PB20_I);

	/****************************************************
	Tie the pin buffer enable inputs LOW for all DAI pins so
	that they are always input pins.  This is GROUP F.
	****************************************************/

    SRU(LOW, PBEN01_I);
    SRU(LOW, PBEN02_I);
    SRU(LOW, PBEN03_I);
    SRU(LOW, PBEN04_I);
    SRU(LOW, PBEN05_I);
    SRU(LOW, PBEN06_I);
    SRU(LOW, PBEN07_I);
    SRU(LOW, PBEN08_I);
    SRU(LOW, PBEN09_I);
    SRU(LOW, PBEN10_I);
    SRU(LOW, PBEN11_I);
    SRU(LOW, PBEN12_I);
    SRU(LOW, PBEN13_I);
    SRU(LOW, PBEN14_I);
    SRU(LOW, PBEN15_I);
    SRU(LOW, PBEN16_I);
    SRU(LOW, PBEN17_I);
    SRU(LOW, PBEN18_I);
    SRU(LOW, PBEN19_I);
    SRU(LOW, PBEN20_I);

}


void Init_DAI_I2S()
{
    Clear_DAI_Pins();

//-----------------------------------------------------------------------------
//  Connect the AD1939 BCLKs and LRCLKs: The AD1939 drives a ABCLK output to
//  input DAI pin 7, a ALRCLK frame sync to DAI pin 8.
//
//  Internally connect ABCLK/ALRCLK DAI pins 7/8 back out to DBCLK/DLRCLK DAI
//  pins 13 and 14, respectively
//
//  In this example, the ADC clocks are master, DAC clocks are slaves
//
//  ABCLK/ALRCLK are always inputs to the SHARC so tie the pin
//  buffer inputs and pin buffer enable inputs all low (already done prior, see
//  initial SRU macro instructions above).
//-----------------------------------------------------------------------------

    SRU(DAI_PB07_O, SPORT1_CLK_I);   // DAIP7 (ABCLK) to SPORT1 CLK (RCLK)
    SRU(DAI_PB07_O, SPORT0_CLK_I);   // DAIP7 (ABCLK) to SPORT0 CLK (TCLK)
    SRU(DAI_PB07_O, SPORT2_CLK_I);   // DAIP7 (ABCLK) to SPORT2 CLK (TCLK)

  /* SRU(DAI_PB07_O, DAI_PB13_I);     // DAIP7 (ABCLK) to DAIP13 (DBCLK)
   SRU(HIGH, PBEN13_I);*/



    SRU(DAI_PB08_O, SPORT1_FS_I);    // DAIP8 (ALRCLK) to SPORT1 FS (RFS1)
    SRU(DAI_PB08_O, SPORT0_FS_I);    // DAIP8 (ALRCLK) to SPORT0 FS (TFS0)
    SRU(DAI_PB08_O, SPORT2_FS_I);    // DAIP8 (ALRCLK) to SPORT2 FS (TFS2)
  /*  SRU(DAI_PB08_O, DAI_PB14_I);     // DAIP8 (ALRCLK) to DAIP14 (DLRCLK)
    SRU(HIGH, PBEN14_I);*/

//-----------------------------------------------------------------------------
//  Connect the AD1939 ADCs: The AD1939 drives I2S rx ADC data to DAI pins 5
//  and 6.  We Connect the I2S ADC stream to SPORT1, using data inputs pri. A
//  and sec. B channels
//
//  These lines are always inputs to the SHARC so tie the pin
//  buffer inputs and pin buffer enable inputs all low. (already done prior,
//  see initial SRU macro instructions above).
//-----------------------------------------------------------------------------

    SRU(DAI_PB05_O, SPORT1_DA_I);    // DAIP5 (ASDATA1) to SPORT1 DA (RX1A)
    SRU(DAI_PB06_O, SPORT1_DB_I);    // DAIP6 (ASDATA2) to SPORT1 DB (RX1B)


//-----------------------------------------------------------------------------
//  Connect the AD1939 DACs in I2S mode to SPORT0 and SPORT2:
//  The DAC clock and frame sync inputs are provided by the ADCs
//
//  All eight DAC connections are always outputs from the SHARC
//  so tie the pin buffer enable inputs all high.
//
//  Connect the I2S DAC streams to SPORT0 A/B and SPORT2 A/B
//  via DAI pins 12, 11, 10 and 9
//
//  Connect DAC1 DSDATA1 to SPORT0, using data output A
//  Connect DAC2 DSDATA2 to SPORT0, using data output B
//  Connect DAC3 DSDATA3 to SPORT2, using data output A
//  Connect DAC4 DSDATA4 to SPORT2, using data output B
//-----------------------------------------------------------------------------

    SRU(HIGH, PBEN12_I);
    SRU(SPORT0_DA_O, DAI_PB12_I);    // DAIP12 (DSDATA1) to SPORT0 DA (TX)
    SRU(HIGH, PBEN11_I);
    SRU(SPORT0_DB_O, DAI_PB11_I);    // DAIP11 (DSDATA2) to SPORT0 DB (TX)


    SRU(HIGH, PBEN10_I);
    SRU(SPORT2_DA_O, DAI_PB10_I);    // DAIP10 (DSDATA3) to SPORT2 DA (TX)
    SRU(HIGH, PBEN09_I);
    SRU(SPORT2_DB_O, DAI_PB09_I);    // DAIP09 (DSDATA4) to SPORT2 DB (TX)





//--------------------------------------------------------------------------
// Route SPI signals to AD1939 Control Port.

    SRU(SPI_MOSI_O, DPI_PB01_I);     //Connect MOSI to DPI PB1.
    SRU(DPI_PB02_O, SPI_MISO_I);     //Connect DPI PB2 to MISO.
    SRU(SPI_CLK_O, DPI_PB03_I);      //Connect SPI CLK to DPI PB3.
    SRU(SPI_FLG0_O, DPI_PB04_I);     //Connect SPI FLAG0 to DPI PB4.


//---------------------------------------------------------------------------
// Tie pin buffer enable from SPI peripheral to determine whether they are
// inputs or outputs

    SRU(SPI_MOSI_PBEN_O, DPI_PBEN01_I);
    SRU(SPI_MISO_PBEN_O, DPI_PBEN02_I);
    SRU(SPI_CLK_PBEN_O, DPI_PBEN03_I);
    SRU(SPI_FLG0_PBEN_O, DPI_PBEN04_I);


//-----------------------------------------------------------------------------
//  Set the SRU and route so that a Flag pins connects to DPI pin buffers.
//  Use Flags 4 to 15 only. Flags 0 to 3 not available on the DPI.
//	SRU(FLAG6_O,DPI_PB08_I);	// Connect Flag6 output to DPI_PB08 input (LED1)
//	SRU(FLAG7_O,DPI_PB13_I);	// Connect Flag7 output to DPI_PB13 input (LED2)
//	SRU(FLAG4_O,DPI_PB06_I);	// Connect Flag4 output to DPI_PB06 input (LED3)
//	SRU(FLAG5_O,DPI_PB07_I);	// Connect Flag5 output to DPI_PB07 input (LED4)
//	SRU(FLAG8_O,DPI_PB14_I);	// Connect Flag8 output to DPI_PB14 input (LED5)

//	SRU(LOW,DAI_PB15_I);		// Connect Input LOW to LED6
//	SRU(LOW,DAI_PB16_I);		// Connect Input LOW to LED7

//Enabling the Buffer using the following sequence: High -> Output, Low -> Input

//	SRU(HIGH,DPI_PBEN08_I);
//	SRU(HIGH,DPI_PBEN13_I);
//	SRU(HIGH,DPI_PBEN06_I);
//	SRU(HIGH,DPI_PBEN07_I);
//	SRU(HIGH,DPI_PBEN14_I);
//	SRU(HIGH,PBEN15_I);
//	SRU(HIGH,PBEN16_I);

}


void Init_TDM_DAI(MODE_SAMPLE_RATE sampe_rate)
{
	int iCounter;

    Clear_DAI_Pins();



//-----------------------------------------------------------------------------
//  Connect the AD1939 ADCs: The AD1939 drives a BCLK output to DAI pin 7,
//          a frame sync to DAI pin 8 and TDM rx data to DAI pins 5
//
//          Connect the TDM ADC stream to SPORT1, using data input A
//
//          All four lines are always inputs to the SHARC so tie the pin
//          buffer inputs and pin buffer enable inputs all low.

    SRU(DAI_PB07_O, SPORT1_CLK_I);   // DAIP7 (RSCLK1) to SPORT1 CLK (CLK)
    SRU(DAI_PB07_O, SPORT0_CLK_I);   // DAIP7 (RSCLK1) to SPORT0 CLK (CLK)

    SRU(DAI_PB08_O, SPORT1_FS_I);    // DAIP8 (RFS1) to SPORT1 FS (FS)
    SRU(DAI_PB08_O, SPORT0_FS_I);    // DAIP8 (RFS1) to SPORT0 FS (FS)

    SRU(DAI_PB05_O, SPORT1_DA_I);    // DAIP5 (DR1PRI) to SPORT1 DA (RX)


//-----------------------------------------------------------------------------
//  Connect the AD1939 DACs in TDM mode to SPORT0:
//          The clock and frame sync inputs are provided by the ADCs
//
//          All DAC connections are always outputs from the SHARC
//          so tie the pin buffer enable inputs all high.
//          Connect the TDM DAC stream to SPORT0 A via DAI pins 11 and 12

    SRU(HIGH, PBEN12_I);
    SRU(SPORT0_DA_O, DAI_PB12_I);    // DAIP12 (DT0PRI)to SPORT0 DA (TX)

    if( sampe_rate  == TDM_192_KHZ_SAMPLE_RATE_OUT12 ||
    	sampe_rate  == TDM_192_KHZ_SAMPLE_RATE_OUT34 ||
    	sampe_rate  == TDM_192_KHZ_SAMPLE_RATE)
    {
	    SRU(HIGH, PBEN10_I);
	    SRU(SPORT0_DB_O, DAI_PB10_I);    // DAIP11 (DT0SEC)to SPORT0 DB (TX)

    }






//--------------------------------------------------------------------------
// Route SPI signals to AD1939 Control Port.

    SRU(SPI_MOSI_O, DPI_PB01_I);     //Connect MOSI to DPI PB1.
    SRU(DPI_PB02_O, SPI_MISO_I);     //Connect DPI PB2 to MISO.
    SRU(SPI_CLK_O, DPI_PB03_I);      //Connect SPI CLK to DPI PB3.
    SRU(SPI_FLG0_O, DPI_PB04_I);     //Connect SPI FLAG0 to DPI PB4.


//---------------------------------------------------------------------------
// Tie pin buffer enable from SPI peipheral to determine whether they are
// inputs or outputs

    SRU(SPI_MOSI_PBEN_O, DPI_PBEN01_I);
    SRU(SPI_MISO_PBEN_O, DPI_PBEN02_I);
    SRU(SPI_CLK_PBEN_O, DPI_PBEN03_I);
    SRU(SPI_FLG0_PBEN_O, DPI_PBEN04_I);


//-----------------------------------------------------------------------------
// Set the SRU and route so that a Flag pins connects to DPI pin buffers.
// Use Flags 4 to 15 only. Flags 0 to 3 not available on the DPI.







	// Enabling the Buffer using the following sequence: High -> Output, Low -> Input


	SRU(HIGH,DPI_PBEN06_I);
	SRU(HIGH,DPI_PBEN13_I);
	SRU(HIGH,DPI_PBEN14_I);




    if( sampe_rate  == TDM_192_KHZ_SAMPLE_RATE_OUT12 ||
    	sampe_rate  == TDM_192_KHZ_SAMPLE_RATE_OUT34 ||
    	sampe_rate  == TDM_192_KHZ_SAMPLE_RATE)
    {
		// Setting the SRU and route so that Flag pins connects to DPI pin buffers.
		// Use Flags 4 to 15 only. Flags 0 to 3 not available on the DPI.

		// 192 kHz
		SRU(FLAG4_O,DPI_PB06_I);	// Connect Flag6 output to DPI_PB06 input (LED1)
		SRU(FLAG5_O,DPI_PB13_I);	// Connect Flag7 output to DPI_PB13 input (LED2)
		SRU(FLAG6_O,DPI_PB14_I);	// Connect Flag4 output to DPI_PB14 input (LED3)

    }else if(sampe_rate  == TDM_48_KHZ_SAMPLE_RATE_OUT12 ||
    	sampe_rate  == TDM_48_KHZ_SAMPLE_RATE_OUT34 ||
    	sampe_rate  == TDM_48_KHZ_SAMPLE_RATE)
	{
		// Setting the SRU and route so that Flag pins connects to DPI pin buffers.
		// Use Flags 4 to 15 only. Flags 0 to 3 not available on the DPI.

		// 48-96 kHz
		SRU(FLAG4_O,DPI_PB06_I);	// Connect Flag4 output to DPI_PB06 input (LED3)
		SRU(FLAG5_O,DPI_PB07_I);	// Connect Flag5 output to DPI_PB07 input (LED4)
		SRU(FLAG6_O,DPI_PB08_I);	// Connect Flag6 output to DPI_PB08 input (LED1)
		SRU(FLAG7_O,DPI_PB13_I);	// Connect Flag7 output to DPI_PB13 input (LED2)
		SRU(FLAG8_O,DPI_PB14_I);	// Connect Flag8 output to DPI_PB14 input (LED5)
		// Enabling the Buffer using the following sequence: High -> Output, Low -> Input

		SRU(LOW,DAI_PB15_I);		// Connect Input LOW to LED6
		SRU(LOW,DAI_PB16_I);		// Connect Input LOW to LED7

		SRU(HIGH,DPI_PBEN07_I);
		SRU(HIGH,DPI_PBEN08_I);
		SRU(HIGH,PBEN15_I);
		SRU(HIGH,PBEN16_I);

	}


}

///////////////////////////////////////////////////////////////////////////////
// Set up all AD1939 registers via SPI
///////////////////////////////////////////////////////////////////////////////

void Init1939viaSPI(MODE_SAMPLE_RATE sampe_rate )
{
    int configSize;
    int i,j=0 ;
    int iControl;
 //   unsigned char tmpA[sizeof(ConfigParam1939) / 3];


    // Get actual configure size
    if(sampe_rate== I2S_48_KHZ_SAMPLE_RATE)
    {
    	configSize = sizeof(ConfigParam1939_48KHZ_I2S);
    	iControl = DS0EN;
    }else if(sampe_rate== I2S_48_KHZ_SAMPLE_RATE_OUT12)
    {
    	configSize = sizeof(ConfigParam1939_48KHZ_I2S_OUT12);
    	iControl = DS0EN;
    }else if(sampe_rate== I2S_48_KHZ_SAMPLE_RATE_OUT34)
    {
    	configSize = sizeof(ConfigParam1939_48KHZ_I2S_OUT34);
    	iControl = DS0EN;
    }else if(sampe_rate== I2S_96_KHZ_SAMPLE_RATE)
    {
    	configSize = sizeof(ConfigParam1939_96KHZ_I2S);
    	iControl = DS0EN;
    }else if(sampe_rate== I2S_96_KHZ_SAMPLE_RATE_OUT12)
    {
    	configSize = sizeof(ConfigParam1939_96KHZ_I2S_OUT12);
    	iControl = DS0EN;
    }else if(sampe_rate== I2S_96_KHZ_SAMPLE_RATE_OUT34)
    {
    	configSize = sizeof(ConfigParam1939_96KHZ_I2S_OUT34);
    	iControl = DS0EN;
    }else if(sampe_rate== I2S_192_KHZ_SAMPLE_RATE)
    {
    	configSize = sizeof(ConfigParam1939_192KHZ_I2S);
    	iControl = DS0EN;
    }else if(sampe_rate== I2S_192_KHZ_SAMPLE_RATE_OUT12)
    {
    	configSize = sizeof(ConfigParam1939_192KHZ_I2S_OUT12);
     	iControl = DS0EN;
   }else if(sampe_rate== I2S_192_KHZ_SAMPLE_RATE_OUT34)
    {
    	configSize = sizeof(ConfigParam1939_192KHZ_I2S_OUT34);
    	iControl = DS0EN;
    }else if(sampe_rate== TDM_48_KHZ_SAMPLE_RATE)
    {
    	configSize = sizeof(ConfigParam1939_48KHZ_TDM);
    	iControl = DS0EN;
    }else if(sampe_rate== TDM_48_KHZ_SAMPLE_RATE_OUT12)
    {
    	configSize = sizeof(ConfigParam1939_48KHZ_TDM_OUT12);
    	iControl = DS0EN;
    }else if(sampe_rate== TDM_48_KHZ_SAMPLE_RATE_OUT34)
    {
    	configSize = sizeof(ConfigParam1939_48KHZ_TDM_OUT34);
    	iControl = DS0EN;
    }else if(sampe_rate== TDM_96_KHZ_SAMPLE_RATE)
    {
    	configSize = sizeof(ConfigParam1939_96KHZ_TDM);
    	iControl = DS0EN;
    }else if(sampe_rate== TDM_96_KHZ_SAMPLE_RATE_OUT12)
    {
    	configSize = sizeof(ConfigParam1939_96KHZ_TDM_OUT12);
    	iControl = DS0EN;
    }else if(sampe_rate== TDM_96_KHZ_SAMPLE_RATE_OUT34)
    {
    	configSize = sizeof(ConfigParam1939_96KHZ_TDM_OUT34);
    	iControl = DS0EN;
    }else if(sampe_rate== TDM_192_KHZ_SAMPLE_RATE)
    {
    	configSize = sizeof(ConfigParam1939_192KHZ_TDM);
    	iControl = DS0EN;
    }else if(sampe_rate== TDM_192_KHZ_SAMPLE_RATE_OUT12)
    {
    	configSize = sizeof(ConfigParam1939_192KHZ_TDM_OUT12);
    	iControl = DS0EN;
    }else if(sampe_rate== TDM_192_KHZ_SAMPLE_RATE_OUT34)
    {
    	configSize = sizeof(ConfigParam1939_192KHZ_TDM_OUT34);
    	iControl = DS0EN;
    }else if(sampe_rate== EXTA_TDM_192_KHZ_SAMPLE_RATE_OUT)
    {
    	configSize = sizeof(ConfigParam1939ExtA_192_TDM_OUT);
    	iControl = DS0EN;
    }else if(sampe_rate== EXTA_TDM_192_KHZ_SAMPLE_RATE_OUT12)
    {
    	configSize = sizeof(ConfigParam1939ExtA_192_TDM_OUT12);
    	iControl = DS0EN;
    }else if(sampe_rate== EXTA_TDM_192_KHZ_SAMPLE_RATE_OUT34)
    {
    	configSize = sizeof(ConfigParam1939ExtA_192_TDM_OUT34);
    	iControl = DS0EN;
    }else if(sampe_rate== EXTB_TDM_192_KHZ_SAMPLE_RATE_OUT12)
    {
    	configSize = sizeof(ConfigParam1939ExtB_192_TDM_OUT12);
    	iControl = DS1EN;
    }else if(sampe_rate== EXTB_TDM_192_KHZ_SAMPLE_RATE_OUT34)
    {
    	configSize = sizeof(ConfigParam1939ExtB_192_TDM_OUT34);
    	iControl = DS1EN;
    }else if(sampe_rate== EXTC_TDM_192_KHZ_SAMPLE_RATE_OUT12)
    {
    	configSize = sizeof(ConfigParam1939ExtC_192_TDM_OUT12);
    	iControl = DS2EN;
    }else if(sampe_rate== EXTC_TDM_192_KHZ_SAMPLE_RATE_OUT34)
    {
    	configSize = sizeof(ConfigParam1939ExtC_192_TDM_OUT34);
    	iControl = DS2EN;
    }else if(sampe_rate== EXTB_CODEC_OFF)
    {
    	configSize = sizeof(ConfigParam1939Ext_Codec_OFF);
    	iControl = DS1EN;
    }else if(sampe_rate== EXTC_CODEC_OFF)
    {
    	configSize = sizeof(ConfigParam1939Ext_Codec_OFF);
    	iControl = DS2EN;
    }


    //Set up AD1939
    SetupSPI1939(iControl);



    //Write register settings
    for(i = 0; i < configSize; i+=3)
    {
		if(sampe_rate== I2S_48_KHZ_SAMPLE_RATE)
		{
        	Configure1939Register(ConfigParam1939_48KHZ_I2S[i], ConfigParam1939_48KHZ_I2S[i+1], ConfigParam1939_48KHZ_I2S[i+2], iControl);
		}else if(sampe_rate== I2S_48_KHZ_SAMPLE_RATE_OUT12)
		{
	       	Configure1939Register(ConfigParam1939_48KHZ_I2S_OUT12[i], ConfigParam1939_48KHZ_I2S_OUT12[i+1], ConfigParam1939_48KHZ_I2S_OUT12[i+2], iControl);
		}else if(sampe_rate== I2S_48_KHZ_SAMPLE_RATE_OUT34)
		{
	       	Configure1939Register(ConfigParam1939_48KHZ_I2S_OUT34[i], ConfigParam1939_48KHZ_I2S_OUT34[i+1], ConfigParam1939_48KHZ_I2S_OUT34[i+2], iControl);

		}else if(sampe_rate== I2S_96_KHZ_SAMPLE_RATE_OUT12)
		{
        	Configure1939Register(ConfigParam1939_96KHZ_I2S_OUT12[i], ConfigParam1939_96KHZ_I2S_OUT12[i+1], ConfigParam1939_96KHZ_I2S_OUT12[i+2], iControl);
		}else if(sampe_rate== I2S_96_KHZ_SAMPLE_RATE_OUT34)
		{
        	Configure1939Register(ConfigParam1939_96KHZ_I2S_OUT34[i], ConfigParam1939_96KHZ_I2S_OUT34[i+1], ConfigParam1939_96KHZ_I2S_OUT34[i+2], iControl);
		}else if(sampe_rate== I2S_192_KHZ_SAMPLE_RATE_OUT12)
		{
        	Configure1939Register(ConfigParam1939_192KHZ_I2S_OUT12[i], ConfigParam1939_192KHZ_I2S_OUT12[i+1], ConfigParam1939_192KHZ_I2S_OUT12[i+2], iControl);
		}else if(sampe_rate== I2S_192_KHZ_SAMPLE_RATE_OUT34)
		{
        	Configure1939Register(ConfigParam1939_192KHZ_I2S_OUT34[i], ConfigParam1939_192KHZ_I2S_OUT34[i+1], ConfigParam1939_192KHZ_I2S_OUT34[i+2], iControl);
		}else if(sampe_rate== TDM_48_KHZ_SAMPLE_RATE_OUT12)
		{
        	Configure1939Register(ConfigParam1939_48KHZ_TDM_OUT12[i], ConfigParam1939_48KHZ_TDM_OUT12[i+1], ConfigParam1939_48KHZ_TDM_OUT12[i+2], iControl);
		}else if(sampe_rate== TDM_48_KHZ_SAMPLE_RATE_OUT34)
		{
        	Configure1939Register(ConfigParam1939_48KHZ_TDM_OUT34[i], ConfigParam1939_48KHZ_TDM_OUT34[i+1], ConfigParam1939_48KHZ_TDM_OUT34[i+2], iControl);
		}else if(sampe_rate== TDM_192_KHZ_SAMPLE_RATE_OUT12)
		{
        	Configure1939Register(ConfigParam1939_192KHZ_TDM_OUT12[i], ConfigParam1939_192KHZ_TDM_OUT12[i+1], ConfigParam1939_192KHZ_TDM_OUT12[i+2], iControl);
		}else if(sampe_rate== TDM_192_KHZ_SAMPLE_RATE_OUT34)
		{
        	Configure1939Register(ConfigParam1939_192KHZ_TDM_OUT34[i], ConfigParam1939_192KHZ_TDM_OUT34[i+1], ConfigParam1939_192KHZ_TDM_OUT34[i+2], iControl);
		}else if(sampe_rate== EXTA_TDM_192_KHZ_SAMPLE_RATE_OUT)
		{
        	Configure1939Register(ConfigParam1939ExtA_192_TDM_OUT[i], ConfigParam1939ExtA_192_TDM_OUT[i+1], ConfigParam1939ExtA_192_TDM_OUT[i+2], iControl);
		}else if(sampe_rate== EXTA_TDM_192_KHZ_SAMPLE_RATE_OUT12)
		{
        	Configure1939Register(ConfigParam1939ExtA_192_TDM_OUT12[i], ConfigParam1939ExtA_192_TDM_OUT12[i+1], ConfigParam1939ExtA_192_TDM_OUT12[i+2], iControl);
		}else if(sampe_rate== EXTA_TDM_192_KHZ_SAMPLE_RATE_OUT34)
		{
        	Configure1939Register(ConfigParam1939ExtA_192_TDM_OUT34[i], ConfigParam1939ExtA_192_TDM_OUT34[i+1], ConfigParam1939ExtA_192_TDM_OUT34[i+2], iControl);
		}else if(sampe_rate== EXTB_TDM_192_KHZ_SAMPLE_RATE_OUT12)
		{
        	Configure1939Register(ConfigParam1939ExtB_192_TDM_OUT12[i], ConfigParam1939ExtB_192_TDM_OUT12[i+1], ConfigParam1939ExtB_192_TDM_OUT12[i+2], iControl);
		}else if(sampe_rate== EXTB_TDM_192_KHZ_SAMPLE_RATE_OUT34)
		{
        	Configure1939Register(ConfigParam1939ExtB_192_TDM_OUT34[i], ConfigParam1939ExtB_192_TDM_OUT34[i+1], ConfigParam1939ExtB_192_TDM_OUT34[i+2], iControl);
		}else if(sampe_rate== EXTC_TDM_192_KHZ_SAMPLE_RATE_OUT12)
		{
        	Configure1939Register(ConfigParam1939ExtC_192_TDM_OUT12[i], ConfigParam1939ExtC_192_TDM_OUT12[i+1], ConfigParam1939ExtC_192_TDM_OUT12[i+2], iControl);
		}else if(sampe_rate== EXTC_TDM_192_KHZ_SAMPLE_RATE_OUT34)
		{
        	Configure1939Register(ConfigParam1939ExtC_192_TDM_OUT34[i], ConfigParam1939ExtC_192_TDM_OUT34[i+1], ConfigParam1939ExtC_192_TDM_OUT34[i+2], iControl);
		}else if(sampe_rate== EXTB_CODEC_OFF || sampe_rate== EXTC_CODEC_OFF)
		{
        	Configure1939Register(ConfigParam1939Ext_Codec_OFF[i], ConfigParam1939Ext_Codec_OFF[i+1], ConfigParam1939Ext_Codec_OFF[i+2], iControl);
		}

        Delay(272);

        //Read back register settings for debugging
   //     AD1938_Regs_Read[j++] = Get1939Register(ConfigParam1939[i+1], AD1939_CS);
   //     Delay(272);
    }

    DisableSPI1939();
}

///////////////////////////////////////////////////////////////////////////////
// Set up the SPI port to access the AD1939
// Call with SPI flag to use
///////////////////////////////////////////////////////////////////////////////

void SetupSPI1939(unsigned int SPI_Flag)
{

/*
	//soft reset ad1393 codec
	SRU(LOW,DAI_PB02_I);
	SRU(HIGH,PBEN02_I);
	SRU(LOW,DAI_PB02_I);

	Delay(500);
	SRU(HIGH,DAI_PB02_I);
*/

    // Configure the SPI Control registers
    // First clear a few registers
    *pSPICTL = (TXFLSH | RXFLSH) ;
    *pSPIFLG = 0;

    // Setup the baud rate to 1MHz
    //*pSPIBAUD = 100;
    *pSPIBAUD = 25;

    // Setup the SPI Flag register using the Flag specified in the call
    *pSPIFLG = (0xF00|SPI_Flag);

    // Now setup the SPI Control register
    *pSPICTL = (SPIEN | SPIMS | WL8 | MSBF | TIMOD1 | CPHASE | CLKPL | SMLS); //works
 //   *pSPICTL = (SPIEN | SPIMS | WL8 | MSBF | TIMOD1 | CPHASE | SMLS);
}


///////////////////////////////////////////////////////////////////////////////
// Disable the SPI Port
///////////////////////////////////////////////////////////////////////////////

void DisableSPI1939(void)
{
    *pSPICTL = (TXFLSH | RXFLSH);
}

///////////////////////////////////////////////////////////////////////////////
// Send a word to the AD1939 via SPI
// Call with the AD1939 address, register address, register data,
// and SPI flag to use
///////////////////////////////////////////////////////////////////////////////

void Configure1939Register (unsigned char rwaddr,unsigned char regaddr,unsigned char regdata, unsigned int spiselect)
{
    int i,j;
    unsigned char val[3];

    SELECT_SPI_SLAVE(spiselect);

    val[0]=WR(rwaddr);
    val[1]=regaddr;
    val[2]=regdata;

    for(i=0;i<3;i++)
    {
        j=0;
        *pTXSPI = val[i] ;
        Delay(136);
        //Wait for the SPI to indicate that it has finished.
        while ((*pSPISTAT & TXS))
        {j++;}
    }

    j=0;
    //Wait for the SPI to indicate that it has finished.
    while (!(*pSPISTAT & SPIF))
    {j++;}

    Delay(136);
    DESELECT_SPI_SLAVE(spiselect);

}

int Test_Audio(MODE_SAMPLE_RATE sampe_rate)
{
  	long lTimeout = (AUDIO_REQUIRED_SAMPLES * 4000);
	volatile int bError = 0; 	// returning 1 indicates a pass, anything else is a fail
	int rate =0;
	int desired_frequency1, desired_frequency2;
	int max_signal_strength1, max_signal_strength2;

	g_iSampleCount = 0;
	g_iSampleIndex =0;

	// set this gobal flag for data process function
	g_mode_sample_rate = sampe_rate;

	
	if(sampe_rate == I2S_48_KHZ_SAMPLE_RATE ||sampe_rate == I2S_48_KHZ_SAMPLE_RATE ||
		sampe_rate == I2S_48_KHZ_SAMPLE_RATE_OUT12 ||sampe_rate == I2S_48_KHZ_SAMPLE_RATE_OUT34 ||
		sampe_rate == I2S_96_KHZ_SAMPLE_RATE_OUT12 ||sampe_rate == I2S_96_KHZ_SAMPLE_RATE_OUT34 ||
		sampe_rate == I2S_192_KHZ_SAMPLE_RATE_OUT12 || sampe_rate == I2S_192_KHZ_SAMPLE_RATE_OUT34||
		sampe_rate == I2S_192_KHZ_SAMPLE_RATE)
	{


	    // Initialize DAI because the SPORT and SPI signals
	    // need to be routed
	    Init_DAI_I2S();


	    // Turn on SPORT0 TX and SPORT1 RX for Multichannel Operation
		enable_SPORT012_I2S_mode();
	}else if(sampe_rate == TDM_48_KHZ_SAMPLE_RATE_OUT12 ||sampe_rate == TDM_48_KHZ_SAMPLE_RATE_OUT34 ||
		sampe_rate == TDM_96_KHZ_SAMPLE_RATE_OUT12 ||sampe_rate == TDM_96_KHZ_SAMPLE_RATE_OUT34 ||
		sampe_rate == TDM_192_KHZ_SAMPLE_RATE_OUT12 || sampe_rate == TDM_192_KHZ_SAMPLE_RATE_OUT34)

	{

		Init_TDM_DAI(sampe_rate);

	    // Turn on SPORT0 TX and SPORT1 RX for Multichannel Operation
		enable_SPORT01_MCM_mode(sampe_rate);
		enable_SPORT01_DMA_channels(sampe_rate);


	}

    // This function will configure the AD1939 codec on the EZ-Board
    Init1939viaSPI(sampe_rate);


	// Unmask SPORT1 RX ISR Interrupt
	adi_int_InstallHandler(ADI_CID_P3I, (ADI_INT_HANDLER_PTR)process_AD1939_samples_ISR, NULL, true);

    // Be in infinite loop and do nothing until done.
    while( g_iSampleCount < AUDIO_REQUIRED_SAMPLES )
    {
    	if( 0 == lTimeout-- )
    	{
    		adi_int_EnableInt(ADI_CID_P3I, false);
    		adi_int_UninstallHandler(ADI_CID_P3I);
		    return 0; // failed to get enough samples
    	}
	    // once the required number of samples has been collected,
	    // process the signal.
    };

    // turn off interrupts so that the data is stable.
	adi_int_EnableInt(ADI_CID_P3I, false);
	adi_int_UninstallHandler(ADI_CID_P3I);



    if(sampe_rate==I2S_48_KHZ_SAMPLE_RATE_OUT12 )
    {
    	rate = SAMPLE_RATE_48KHZ;
    	desired_frequency1 = DESIRED_FREQ1_I2S_48_OUT12;
    	desired_frequency2 = DESIRED_FREQ2_I2S_48_OUT12;
    	max_signal_strength1 = MAX_SIGNAL_STRENGTH1_I2S_48_OUT12;
    	max_signal_strength2 = MAX_SIGNAL_STRENGTH2_I2S_48_OUT12;


    }else if(sampe_rate==I2S_48_KHZ_SAMPLE_RATE_OUT34)
    {
    	rate = SAMPLE_RATE_48KHZ;
    	desired_frequency1 = DESIRED_FREQ1_I2S_48_OUT34;
    	desired_frequency2 = DESIRED_FREQ2_I2S_48_OUT34;
    	max_signal_strength1 = MAX_SIGNAL_STRENGTH1_I2S_48_OUT34;
    	max_signal_strength2 = MAX_SIGNAL_STRENGTH2_I2S_48_OUT34;


    }else if(sampe_rate==I2S_96_KHZ_SAMPLE_RATE ||
    		sampe_rate==I2S_96_KHZ_SAMPLE_RATE_OUT12 ||
    		sampe_rate==I2S_96_KHZ_SAMPLE_RATE_OUT34 )
    {
    	// not supported yet
    	/*
    	rate = SAMPLE_RATE_96KHZ;
    	desired_frequency1 = DESIRED_FREQ1_96;
    	desired_frequency2 = DESIRED_FREQ2_96;
    	max_signal_strength1 = MAX_SIGNAL_STRENGTH1_96;
    	max_signal_strength2 = MAX_SIGNAL_STRENGTH2_96;
    	*/


    }else if(sampe_rate==I2S_192_KHZ_SAMPLE_RATE_OUT12 )
    {
    	rate = SAMPLE_RATE_192KHZ;
    	desired_frequency1 = DESIRED_FREQ1_I2S_192_OUT12;
    	desired_frequency2 = DESIRED_FREQ2_I2S_192_OUT12;
    	max_signal_strength1 = MAX_SIGNAL_STRENGTH1_I2S_192_OUT12;
    	max_signal_strength2 = MAX_SIGNAL_STRENGTH2_I2S_192_OUT12;


    }else if(sampe_rate==I2S_192_KHZ_SAMPLE_RATE_OUT34 )
    {
    	rate = SAMPLE_RATE_192KHZ;
    	desired_frequency1 = DESIRED_FREQ1_I2S_192_OUT34;
    	desired_frequency2 = DESIRED_FREQ2_I2S_192_OUT34;
    	max_signal_strength1 = MAX_SIGNAL_STRENGTH1_I2S_192_OUT34;
    	max_signal_strength2 = MAX_SIGNAL_STRENGTH2_I2S_192_OUT34;


    }else if(sampe_rate==TDM_48_KHZ_SAMPLE_RATE_OUT12 )
    {
    	rate = SAMPLE_RATE_48KHZ;
    	desired_frequency1 = DESIRED_FREQ1_TDM_48_OUT12;
    	desired_frequency2 = DESIRED_FREQ2_TDM_48_OUT12;
    	max_signal_strength1 = MAX_SIGNAL_STRENGTH1_TDM_48_OUT12;
    	max_signal_strength2 = MAX_SIGNAL_STRENGTH2_TDM_48_OUT12;


    }else if(sampe_rate==TDM_48_KHZ_SAMPLE_RATE_OUT34 )
    {
    	rate = SAMPLE_RATE_48KHZ;
    	desired_frequency1 = DESIRED_FREQ1_TDM_48_OUT34;
    	desired_frequency2 = DESIRED_FREQ2_TDM_48_OUT34;
    	max_signal_strength1 = MAX_SIGNAL_STRENGTH1_TDM_48_OUT34;
    	max_signal_strength2 = MAX_SIGNAL_STRENGTH2_TDM_48_OUT34;


    }else if(sampe_rate==TDM_96_KHZ_SAMPLE_RATE ||
    		sampe_rate==TDM_96_KHZ_SAMPLE_RATE_OUT12 ||
    		sampe_rate==TDM_96_KHZ_SAMPLE_RATE_OUT34 )
    {
    	//not supported yet
    	/*
    	rate = SAMPLE_RATE_96KHZ;
    	desired_frequency1 = DESIRED_FREQ2_96;
    	desired_frequency2 = DESIRED_FREQ1_96;
    	max_signal_strength1 = MAX_SIGNAL_STRENGTH1_TDM_96;
    	max_signal_strength2 = MAX_SIGNAL_STRENGTH2_TDM_96;

    	*/
    }

    else if(sampe_rate==TDM_192_KHZ_SAMPLE_RATE_OUT12  )
    {
    	rate = SAMPLE_RATE_192KHZ;
    	desired_frequency1 = DESIRED_FREQ1_TDM_192_OUT12;
    	desired_frequency2 = DESIRED_FREQ2_TDM_192_OUT12;
    	max_signal_strength1 = MAX_SIGNAL_STRENGTH1_TDM_192_OUT12;
    	max_signal_strength2 = MAX_SIGNAL_STRENGTH2_TDM_192_OUT12;


    }else if(sampe_rate==TDM_192_KHZ_SAMPLE_RATE_OUT34 )
    {
    	rate = SAMPLE_RATE_192KHZ;
    	desired_frequency1 = DESIRED_FREQ1_TDM_192_OUT34;
    	desired_frequency2 = DESIRED_FREQ2_TDM_192_OUT34;
    	max_signal_strength1 = MAX_SIGNAL_STRENGTH1_TDM_192_OUT34;
    	max_signal_strength2 = MAX_SIGNAL_STRENGTH2_TDM_192_OUT34;


    }


    // test the left channel
    bError = Test_Channel((float*)g_fSineWaveIn1_Left,  AUDIO_MAX_SAMPLES,
    						rate, desired_frequency1,
    						ACCEPTABLE_DEVIATION_PCT,
    						max_signal_strength1,
    						max_signal_strength1);
    if( 1 == bError )
    {
    	// test the right channel
    	bError = Test_Channel((float*)g_fSineWaveIn1_Right, AUDIO_MAX_SAMPLES,
    							rate, desired_frequency1,
    							ACCEPTABLE_DEVIATION_PCT,
    							max_signal_strength1,
    							max_signal_strength1);
    }

    if( 1 == bError )
    {
    	// test the right channel
    	bError = Test_Channel((float*)g_fSineWaveIn2_Left, AUDIO_MAX_SAMPLES,
    							rate, desired_frequency2,
    							ACCEPTABLE_DEVIATION_PCT,
    							max_signal_strength2,
    							max_signal_strength2);
    }

    if( 1 == bError )
    {
    	// test the right channel
    	bError = Test_Channel((float*)g_fSineWaveIn2_Right, AUDIO_MAX_SAMPLES,
    							rate, desired_frequency2,
    							ACCEPTABLE_DEVIATION_PCT,
    							max_signal_strength2,
    							max_signal_strength2);
    }





    if( 0 == bError )
    {
    	return bError;
    }


	return bError;

}

void 	enable_SPORT012_I2S_mode()
{
	/* Clear out SPORT 0/1/2 registers */
    *pSPCTL0 = *pSPCTL1 = *pSPCTL2 = 0;
    *pSPMCTL0 = *pSPMCTL1 = *pSPMCTL2 = 0;
    *pSPCTLN1 = *pSPCTLN0 = *pSPCTLN2 = 0;

    /* External clock and frame syncs generated by AD1939 */
   	*pDIV0 = 0x00000000;  // Transmitter (SPORT0)
    *pDIV1 = 0x00000000;  // Receiver (SPORT1) at 12.288 MHz SCLK and 48 kHz sample rate

	/* SPORT0 and SPORT1 are being operated in "I2S" mode.
	This is synonymous with stereo operating mode for the AD1939 */

	I2S_rcv1a_tcb[4]  = *pCPSP1A = ((int) (I2S_rcv1a_tcb  + 7) & 0x7FFFF) | (1<<19);
	I2S_rcv1b_tcb[4]  = *pCPSP1B = ((int) (I2S_rcv1b_tcb  + 7) & 0x7FFFF) | (1<<19);
	I2S_xmit0a_tcb[4] = *pCPSP0A = ((int) (I2S_xmit0a_tcb + 7) & 0x7FFFF) | (1<<19);
	I2S_xmit0b_tcb[4] = *pCPSP0B = ((int) (I2S_xmit0b_tcb + 7) & 0x7FFFF) | (1<<19);
	I2S_xmit2a_tcb[4] = *pCPSP2A = ((int) (I2S_xmit2a_tcb + 7) & 0x7FFFF) | (1<<19);
	I2S_xmit2b_tcb[4] = *pCPSP2B = ((int) (I2S_xmit2b_tcb + 7) & 0x7FFFF) | (1<<19);

	/* SPORT1 control register is set up as a receiver in I2S for ADC1 and ADC2 */
	/* SPORT1  control register SPCTL1 = 0x00000000 */
	/* externally generated SCLK1 and RFS1 */
	/* primary and secondary channels enabled with DMA chaining */
	*pSPCTL1 = (OPMODE | SLEN32 | SPEN_A | SCHEN_A | SDEN_A | SPEN_B | SCHEN_B | SDEN_B);

	/* SPORT0 control register set up as a transmitter in I2S for DAC1 and DAC2*/
	/* externally generated SCLK0 and RFS0 */
	/* primary and secondary channels enabled with DMA chaining */
	*pSPCTL0 = (SPTRAN | OPMODE | SLEN32 | SPEN_A | SCHEN_A | SDEN_A | SPEN_B | SCHEN_B | SDEN_B);

	/* SPORT2 control register set up as a transmitter in I2S for DAC3 and DAC4 */
	/* externally generated SCLK2 and RFS2 */
	/* primary and secondary channels enabled with DMA chaining */
	*pSPCTL2 = (SPTRAN | OPMODE | SLEN32 | SPEN_A | SCHEN_A | SDEN_A | SPEN_B | SCHEN_B | SDEN_B);
}


void 	enable_SPORT01_MCM_mode(MODE_SAMPLE_RATE sampe_rate)
{
	/* Clear out SPORT 0/1 registers */
	*pSPMCTL0 = 0;
	*pSPMCTL1 = 0;
    *pSPCTL0 = 0;
    *pSPCTL1 = 0;

    /* External clock and frame syncs generated by AD1939 */
   	*pDIV0 = 0x00000000;  // Transmitter (SPORT0)
    *pDIV1 = 0x00000000;  // Receiver (SPORT1) at 12.288 MHz SCLK and 48 kHz sample rate

	if(sampe_rate== TDM_48_KHZ_SAMPLE_RATE ||
		sampe_rate== TDM_48_KHZ_SAMPLE_RATE_OUT12 ||
		sampe_rate== TDM_48_KHZ_SAMPLE_RATE_OUT34 ||
		sampe_rate== TDM_96_KHZ_SAMPLE_RATE ||
		sampe_rate== TDM_96_KHZ_SAMPLE_RATE_OUT12 ||
		sampe_rate== TDM_96_KHZ_SAMPLE_RATE_OUT34)

	{
		/* SPORT0 and SPORT1 are being operated in "multichannel" mode.
		This is synonymous with TDM mode which is the operating mode for the AD1939 */

		/* SPORT 0&1  Miscellaneous Control Bits Registers */
		/* SP01MCTL = 0x000000E2,  Hold off on MCM enable, and number of TDM slots to 8 active channels */
		/* Multichannel Frame Delay=1, Number of Channels = 8, LB disabled */
		//*pSPMCTL01 = NCH_8 | MFD1;
		*pSPMCTL0 = NCH7 | MFD1;
		*pSPMCTL1 = NCH7 | MFD1;

		/* sport1 control register set up as a receiver in MCM */
		/* sport 1 control register SPCTL1 = 0x000C01F0 */
		/* externally generated SCLK1 and RFS1 */
		*pSPCTL1 = 	SCHEN_A | SDEN_A | SLEN32;

		/* sport0 control register set up as a transmitter in MCM */
		/* sport 0 control register, SPCTL2 = 0x000C01F0 */
		//*pSPCTL0 = 	SCHEN_A | SDEN_A | SPTRAN | FSR | SLEN32;
		*pSPCTL0 = 	SCHEN_A | SDEN_A | SPTRAN | SLEN32;

		/* sport1 receive & sport0 transmit multichannel word enable registers */
		/* enable receive channels 0-7 */
		/* enable transmit channels 0-7 */
		*pMR1CS0 = *pMT0CS0 =0x000000FF;

	}else if(sampe_rate== TDM_192_KHZ_SAMPLE_RATE ||
		sampe_rate== TDM_192_KHZ_SAMPLE_RATE_OUT12 ||
		sampe_rate== TDM_192_KHZ_SAMPLE_RATE_OUT34 ||
		sampe_rate== EXTA_TDM_192_KHZ_SAMPLE_RATE_OUT12 ||
		sampe_rate== EXTA_TDM_192_KHZ_SAMPLE_RATE_OUT34 ||
		sampe_rate== EXTB_TDM_192_KHZ_SAMPLE_RATE_OUT12 ||
		sampe_rate== EXTB_TDM_192_KHZ_SAMPLE_RATE_OUT34 ||
		sampe_rate== EXTC_TDM_192_KHZ_SAMPLE_RATE_OUT12 ||
		sampe_rate== EXTC_TDM_192_KHZ_SAMPLE_RATE_OUT34 )
	{
		/* SPORT0 and SPORT1 are being operated in "multichannel" mode.
		This is synonymous with TDM mode which is the operating mode for the AD1939 */

		/* SPORT 0&1  Miscellaneous Control Bits Registers */
		/* SP01MCTL = 0x000000E2,  Hold off on MCM enable, and number of TDM slots to 8 active channels */
		/* Multichannel Frame Delay=1, Number of Channels = 4, LB disabled */
		*pSPMCTL0 = NCH3 | MFD1;
		*pSPMCTL1 = NCH3 | MFD1;

		/* sport1 control register set up as a receiver in MCM */
		/* sport 1 control register SPCTL1 = 0x000C01F0 */
		/* externally generated SCLK1 and RFS1 */
		*pSPCTL1 = 	SCHEN_A | SDEN_A | SLEN32;

		/* sport0 control register set up as a transmitter in MCM */
		/* sport 0 control register, SPCTL0 = 0x000C01F0 */
		*pSPCTL0 = 	SCHEN_B | SDEN_B | SCHEN_A | SDEN_A | SPTRAN | SLEN32;

		/* sport1 receive & sport0 transmit multichannel word enable registers */
		/* enable receive channels 0-3 */
		/* enable transmit channels 0-3 */
		*pMR1CS0 = *pMT0CS0 =0x0000000F;



	}

	/* sport1 & sport0 receive & transmit multichannel companding enable registers */
	/* no companding for our 8 active timeslots*/
	/* no companding on SPORT1 receive */
	/* no companding on SPORT0 transmit */
	*pMR1CCS0 = *pMT0CCS0 = 0;


	/* Enable Frame Sync Edge Detection in TDM Mode for SPORT0 and SPORT 1 */
	*pSPCTLN1 = FSED;
	*pSPCTLN0 = FSED;
}

void 	enable_SPORT01_DMA_channels(MODE_SAMPLE_RATE sampe_rate)
{
	if(sampe_rate== TDM_48_KHZ_SAMPLE_RATE ||
		sampe_rate== TDM_48_KHZ_SAMPLE_RATE_OUT12 ||
		sampe_rate== TDM_48_KHZ_SAMPLE_RATE_OUT34 ||
		sampe_rate== TDM_96_KHZ_SAMPLE_RATE ||
		sampe_rate== TDM_96_KHZ_SAMPLE_RATE_OUT12 ||
		sampe_rate== TDM_96_KHZ_SAMPLE_RATE_OUT34)

	{
		TDM_4896_xmit0a_tcb[4] = *pCPSP0A = ((int) (TDM_4896_xmit0a_tcb + 7) & 0x7FFFF) | (1<<19);
		TDM_4896_rcv1a_tcb[4]  = *pCPSP1A = ((int) (TDM_4896_rcv1a_tcb  + 7) & 0x7FFFF) | (1<<19);

		// Enable multichannel operation (SPORT mode and DMA in standby and ready)
		*pSPMCTL0 |= MCEA;
	}else if(sampe_rate== TDM_192_KHZ_SAMPLE_RATE ||
		sampe_rate== TDM_192_KHZ_SAMPLE_RATE_OUT12 ||
		sampe_rate== TDM_192_KHZ_SAMPLE_RATE_OUT34)
	{

		TDM_xmit0a_tcb[4] = *pCPSP0A = ((int) (TDM_xmit0a_tcb + 7) & 0x7FFFF) | (1<<19);
		TDM_xmit0b_tcb[4] = *pCPSP0B = ((int) (TDM_xmit0b_tcb + 7) & 0x7FFFF) | (1<<19);
		TDM_rcv1a_tcb[4]  = *pCPSP1A = ((int) (TDM_rcv1a_tcb  + 7) & 0x7FFFF) | (1<<19);
		// Enable multichannel operation (SPORT mode and DMA in standby and ready)
		*pSPMCTL0 |= MCEA | MCEB;
	}
	*pSPMCTL1 |= MCEA;
}

void  process_AD1939_samples_ISR( int sig_int, void *pCBParam)
{

	/* Perform AD1939 Audio Processing Here Using 32-bit Floating-point Math
	   (Note: The ADC/DAC variables below are used to "double-buffer" the audio
	   samples with temporary variables, allowing active DMA completion of
	   rx1a_buf[] and tx0a_buf[]) */

	if( g_mode_sample_rate == I2S_48_KHZ_SAMPLE_RATE ||g_mode_sample_rate == I2S_96_KHZ_SAMPLE_RATE ||
		g_mode_sample_rate == I2S_48_KHZ_SAMPLE_RATE_OUT12 ||g_mode_sample_rate == I2S_48_KHZ_SAMPLE_RATE_OUT34 ||
		g_mode_sample_rate == I2S_96_KHZ_SAMPLE_RATE_OUT12 ||g_mode_sample_rate == I2S_96_KHZ_SAMPLE_RATE_OUT34 ||
		g_mode_sample_rate == I2S_192_KHZ_SAMPLE_RATE_OUT12 || g_mode_sample_rate == I2S_192_KHZ_SAMPLE_RATE_OUT34 ||
		g_mode_sample_rate == I2S_192_KHZ_SAMPLE_RATE)
	{
		Receive_ADC_Samples_I2S();
	}else if(g_mode_sample_rate== TDM_48_KHZ_SAMPLE_RATE ||
		g_mode_sample_rate== TDM_48_KHZ_SAMPLE_RATE_OUT12 ||
		g_mode_sample_rate== TDM_48_KHZ_SAMPLE_RATE_OUT34 ||
		g_mode_sample_rate== TDM_96_KHZ_SAMPLE_RATE ||
		g_mode_sample_rate== TDM_96_KHZ_SAMPLE_RATE_OUT12 ||
		g_mode_sample_rate== TDM_96_KHZ_SAMPLE_RATE_OUT34)
	{
		//48 & 96 KHz sample rate
		Receive_ADC_Samples_TDM_4896KHZ();
	}else if(g_mode_sample_rate== TDM_192_KHZ_SAMPLE_RATE ||
		g_mode_sample_rate== TDM_192_KHZ_SAMPLE_RATE_OUT12 ||
		g_mode_sample_rate== TDM_192_KHZ_SAMPLE_RATE_OUT34)
	{
		//192 KHz sample rate
		Receive_ADC_Samples_TDM();
	}

	/* Loop back AD1939 ADC1 data to DAC1 */
	Left_Channel_Out1 = Left_Channel_In1;
	Right_Channel_Out1 = Right_Channel_In1;



	/* create a simple stereo digital delay on internal AD1939 stereo DAC2 channels */
	/* Delay-line length must not exceed usable seg_dmda memory addresses! */
	Left_Channel_Out2 = Left_Channel_In2;			// loopback left channel, no processing
	Right_Channel_Out2 = Right_Channel_In2;
//	Right_Channel_Out2 = DelayLine[Index] + Right_Channel_In1; // delayed left + right channel

//	DelayLine[Index++] = Right_Channel_In1;		// store right channel into delay-line
//	if (Index == 16000) Index = 0;

	/* loop back ADC1 audio data to other DACs 3 & 4 */
	Left_Channel_Out3 = Left_Channel_In2;
	Right_Channel_Out3 = Right_Channel_In2;
	Left_Channel_Out4 = Left_Channel_In2;
	Right_Channel_Out4 = Right_Channel_In2;

	if( g_mode_sample_rate == I2S_48_KHZ_SAMPLE_RATE ||g_mode_sample_rate == I2S_96_KHZ_SAMPLE_RATE ||
		g_mode_sample_rate == I2S_48_KHZ_SAMPLE_RATE_OUT12 ||g_mode_sample_rate == I2S_48_KHZ_SAMPLE_RATE_OUT34 ||
		g_mode_sample_rate == I2S_96_KHZ_SAMPLE_RATE_OUT12 ||g_mode_sample_rate == I2S_96_KHZ_SAMPLE_RATE_OUT34 ||
		g_mode_sample_rate == I2S_192_KHZ_SAMPLE_RATE_OUT12 || g_mode_sample_rate == I2S_192_KHZ_SAMPLE_RATE_OUT34 ||
		g_mode_sample_rate == I2S_192_KHZ_SAMPLE_RATE)
	{
		Transmit_DAC_Samples_I2S();
	}else if(g_mode_sample_rate== TDM_48_KHZ_SAMPLE_RATE ||
		g_mode_sample_rate== TDM_48_KHZ_SAMPLE_RATE_OUT12 ||
		g_mode_sample_rate== TDM_48_KHZ_SAMPLE_RATE_OUT34 ||
		g_mode_sample_rate== TDM_96_KHZ_SAMPLE_RATE ||
		g_mode_sample_rate== TDM_96_KHZ_SAMPLE_RATE_OUT12 ||
		g_mode_sample_rate== TDM_96_KHZ_SAMPLE_RATE_OUT34)
	{
		//48 & 96 KHz sample rate
		Transmit_DAC_Samples_TDM_4896KHZ();
	}else if(g_mode_sample_rate== TDM_192_KHZ_SAMPLE_RATE ||
		g_mode_sample_rate== TDM_192_KHZ_SAMPLE_RATE_OUT12 ||
		g_mode_sample_rate== TDM_192_KHZ_SAMPLE_RATE_OUT34)
	{
		//192 KHz sample rate
		Transmit_DAC_Samples_TDM();
	}


	g_fSineWaveIn1_Right[g_iSampleIndex] = Right_Channel_In1;
	g_fSineWaveIn1_Left[g_iSampleIndex] = Left_Channel_In1;

	g_fSineWaveIn2_Right[g_iSampleIndex] = Right_Channel_In2;
	g_fSineWaveIn2_Left[g_iSampleIndex] = Left_Channel_In2;


	g_iSampleIndex++;	// only increment the index when both channels have been sent.


	if( g_iSampleIndex > AUDIO_MAX_SAMPLES-1 )
		g_iSampleIndex = 0;

	g_iSampleCount++;

}


